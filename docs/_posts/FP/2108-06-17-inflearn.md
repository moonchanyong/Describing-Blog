---
layout: post
title: 인프런 유인동님 강의
category: [ FP ]
tags: [ 함수형, 프로그래밍, 함수형 프로그래밍, FP, FunctionalProgramming ]
---

# 인프런 강의 보기

**FP in js ebook으로 본 내용 다시하지만 범주이론 제대로 공부하기 전에 봐두려고한다.**

## each

```javascript
  // 단순하게 전체 리스트를 순회하며 입력받은 함수 실행
  function _each(list: Object, iter: function) {
    for (let i = 0; i < list.length; i+=1) {
      iter(list[i]);
    }
  }
```

## 다형성

### 굳이 있는 함수들을 왜 만들었을까(이미 js에서 구현되있는)

* 맵이나 필터함수는 mothod(메소드는 순수함수가아니라 객체 상태에 따라 결과가 달라진다.)

* 메소드는 객체지향 프로그래밍

* Array가아니면 다른곳에서 사용할 수있다.(Array-Like에는 length만있고 없다)


**메소드는 다형성을 지워하기에어려운 부분이있다.**

직접 구현해서 length만 있다면 수행 할 수있도록 한다.


### 내부 다형성

* 함수의 함수(파라미터로 받는 함수, 어떤 역할을 하냐에 따라 다양한 이름을 갖는다.)

* predicater(조건을 리턴하는 함수), iter(순회하면서 실행하는), mapper(무엇과 무엇을 매핑하는 함수)하는 역할에 맞는 보조함수의 이름을 넣는것이 좋다고 한다.

* 배열안에 어떤값이 들어있어도 수행할 수있도록 하는것은 보조함수가한다.(그러므로 내부의 다형성은 보조함수) 개발자가 넘기는 값에 의존한다.

### 커링

* 함수의 인자를 하나씩 적용하다가 필요한 인자가 다 채워지면 실행

* js에서는 지원하지 않지만 사용 할 수 는있다.

* 원하는 시점까지 나웠다가 조건이 만족했을대 실행하는 기법(함수형 냄새)

```javascript
// 이건 인자가 두개밖에 안되서 확장성 없는 커링
function _curry(fn) {
  (a,b) =>
  (arguments.length == 2)? fn(a, b) : (a) => {
    return (b) => fn(a, b);
  };
}

let add = (a, b) => a+b;
console.log(add(a, b));

let _add = _curry((a, b) => a+b);
let add10 = add(10);
console.log(add10(5));
console.log(_add(5)(3));
console.log(_add(5,3));

// 오른쪽부터 인자적용
function _curryr(fn) {
  return (a,b) => (arguments.length == 2)? fn(b, a) : (b) => fn(b, a);
}

/**
  get을 만들어 좀 더 간단하게 하기
  콘솔에서 없는 유저를 참조하면 에러가 나지 않고 undefined가 된다.
 */
function _get(obj, key) {
  return obj == null? undefined: obj[key];
}
```


## reduce

```javascript
// memo는 초기화 값, 값을 저장한다.
// 오.. 이거 memo라는 값도 상태일까 생각햇는데 이정도는 괜찮나봄
// 펑션내 상태는 상태가 아니다 정도 ?
function _reduce(list, iter, memo) {
  if(arguments.length == 2) {
    memo = list[0];
    // slice는 Array의 메소드라서 이건 다형성이 제한된다.
    // Array-like 객체는 사용하지 못한다.
    // slice의 메소드르 따로 빼내어서 call을통해서 사용하자고 함
    // Array.from()을 사용하자고 airbnb에서 말하니까 이것을 사용하는 것도 괜찮은듯
    list = list.slice(1);

  }
  _each(list, (val) => {memo = iter(memo, val)});
  return memo;
}

console.log(_reduce([], (a, b) => a + b), 0)

```

## pipe

```javascript
// 함수를 다루는 함수
// es6문법
function _pipe(...arg) {
  return (val) =>  _reduce(arg, (val, fn)=> fn(val), val);
}

// pipe한 함수를 바로 실행
function _go(...arg) {
  let fns = _rest(arg);
  return _pipe.apply(null, fns)(arg[0]);
}

let f1 = _pipe(
  (a) => a+1,
  (a) => a*2
)

```

## 다형성높이기, _keys, 에러

* 함수형 프로그래밍에서는 예외적인 데이터가 에러가 나지않도록 하는 프로그래밍을 한다.
* try, catch안한다. underscore에서는 템플릿 외에서는 한번도 안나온다
* 예외를 안하면 안좋지않나요? 자바스크립트 진영에서 다른 프레임워크 내부에서 언더스코어나 노대시 사용하므로 괜찮다고한다, 코어에서 가지고있으므로 괜찮지 않을까라는 말

**어떠한 데이터가 들어와도 실행이되도록한다.**

``` javascript

function _get(obj, key) {
  return obj == null? undefined: obj[key];
}

function _each(list, iter) {
  let _length = curryr(_get)('length');
  for (let i = 0; i < _length(list); i++) {
    iter(list[i]);
  }
}
// 원래는 each에서 현재는 에러가 난다.
// 하지만 _get에서 undefined로 바꿔줘서 동작이 되게 한다.
_each(null, console.log);

// keys , Object.keys()를 안전하게

function _is_object(obj) {
  return typeof obj == 'object' & !!obj;
}

function _keys(obj) {
  return _is_object(obj) ? Object.keys(obj) : [];
}


// each의 다형성 높이기 (object에서도 가능하게)
function _each(list: Object, iter: function) {
  let keys = _keys(list); //return arraytype
  for (let i = 0; i < keys.length; i+=1) {
    iter(list[i]);
  }
}

_each({ key: value }, console.log)

```

# 컬렉션 중심 프로그래밍

4가지 유형과 함수, 대표함수

1. 수집하기 map => values, pluck

2. 거르기 filter => reject, compact, without

3. 찾아내기 find  => some, every

4. 접기 reduce => min, max, group_by, count_by

```javascript

// 사용할 데이터
let users = [
  { id:1, name:'안녕', age:21 },
  { id:2, name:'헬로우', age:22 },
  { id:3, name:'니하오', age:23 },
  { id:4, name:'봉주르', age:24 },
  { id:5, name:'곰방와', age:25 },
  { id:6, name:'하이', age:26 },
  { id:7, name:'곤니찌와', age:27 },
  { id:8, name:'쥬뗌므', age:28 },
]

function  _map(arr, iter) {
  if (!iter) return function(arr2) { return f(arr2, arr) };
  var i = -1, len = arr && arr.length, res = [];
  while (++i < len) res[i] = iter(arr[i]);
  return res;
};

```

## 수집하기 - values, pluck


```javascript

console.log(
  _map(users, (user) => user.name));
)

// values 키밸류쌍이든 모든 Object 값을 빼낸다
function _values(data) {
  return _map(data, _identity);
}

// mapper 보조함수와같음
function _identity(val) {
  return val;
}

//identity 사용..
var a = 10;
console.log(_identity(a));

let _curryrmap = _curryr(_map);

console.log(_currymap(_identity)(users)); //values와 동일한 역할을 하는함수

// pluck, 객체리스트에서 각 객체의 키값의 값을 뺀다.
function _pluck(data, key) {
  return _map(data, (obj) => obj[key]);
}

_pluck(users, 'age'); //[나이, 나이, 나이 ...]

```

## 거르기 - reject, compact

**아 써보고싶다 토이프로젝트 하나할까 써보고싶다**
**하하 토익해야해**

```javascript

//거르기

// reject, filter와 반대동작
function _reject(data, predi) {
  return _filter(data, _negate(predi));
}

console.log(
  // 30세 이상인 사람만 제외, filter 반대
  _reject(users, (user) => user.age > 30);
)

// 반대로 하는, 언더스코어에도 있다.
function _negate(func) {
  return (val) => !func(val);
}

let _compact =  _curryr(_filter)(_identity);

console.log(_compact([1, 2, 0, false, null, {}])) //

```


## 찾아내기 - find, find_index, some, every

```javascript
// 첫번째 사람만 찾는다 현재는
// 지연평가에도 연관이 있다.
function _find(list, predi) {
  let keys = _keys(list);
  for (let i = 0, len = keys.length; i < len; i++){
    let val = list[keys[i]];
    if(predi(val)) return val;
  }
}

console.log(
  _find(users, (user) => user.age < 30)
)

function _find_index(list, predi) {
  let keys = _keys(list);
  for (let i = 0; i < keys.length; i++) {
    if(predi(list[keys[i]])) return i;
  }
  return -1;
}

// some, 리스트 중 조건에 맞는게 하나라도 있으면
function _some(list, predi) {
  return _find_index(list, predi) != -1;
}

// every, 리스트의 모든값이 같다
function _every(list, predi) {
  return _find_index(list, _negate(predi)) == -1;
}

// 조건에 맞는게 하나가 있다면 true
_some([1, 21], (val) => val>10) // true

```


## 접기 - reduce, min_by, max_by

* reduce : for문을 대체하는방식으로reduce를 사용하기보다, 평가순서와 상관없이 접어서 축약하는것으로 이해를 해야한다.

```javascript
// 접기, _reduce
// 앞에서부터 평가한다고 생각하는게 아니라, 모든 값들에 적용되는 것으로 생각하고 생각해야한다.
function _min(list) {
    return _reduce(list, (a, b) => (a < b)? a:b);
}

function _max(list) {
  return _reduce(list, (a, b) => (a < b)? b:a);
}

// 다형성이 낮다, 값들을 직접적으로 비교한다.
// 값들에 어떤 함수를 적용한 후 비교한다.
function _min_by(list, iter) {
  // 흠.. 이러면 두번 iter 적용하지 => 리스트의 값을 변경하지 않으려고 그대로 리턴
  return _reduce(list, (a, b) => iter(a) < iter(b) ? a : b);
}

function _max_by() {
  return _reduce(list, (a, b) => iter(a) > iter(b) ? a : b);
}

console.log(_min_by([], Math.abs);

```

## 접기2 - reduce, group_by, count_by, 조합
**this에 대한 이해가 중요하다. 만약 bind등 잘못쓰면 워하는대로 흘러가지 않는다.**
```javascript

function _push(obj, key, val) {
  (obj[key] = obj[key] || []).push(val);
  return obj;
}

function _group_by(list, iter) {
  return _reduce(list, (grouped, val) => {
    _push(grouped, iter(val), val);
  }, {})
}

function _inc(count, key) {
  count[key] ? count[key]++ : count[key] = 1;
  return count;
}

_group_by(users, (user) => user.age);

function _count_by(list, iter) {
  return _reduce(list, (count, val) => _inc(count, iter(val)), {})
}


let pairs = _map_curryr((val, key) => [key, val]);

```
